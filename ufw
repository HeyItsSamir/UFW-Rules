#! /usr/bin/env python
#
# ufw: front-end for Linux firewalling
#
# Copyright (C) 2007 Canonical <jamie@ubuntu.com>
#
#    ufw is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published
#    by the Free Software Foundation; either version 2 of the License,
#    or (at your option) any later version.
#
#    ufw is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with ufw; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

import os, re, shutil, stat, subprocess, sys
from stat import *
from tempfile import mkstemp

version = "0.0"
programName = os.path.basename(sys.argv[0])

# make sure we are at least version 2.4
if sys.version_info[0] < 2 or sys.version_info[1] < 4:
    print >> sys.stderr, programName + ": Need at least python 2.4\n"
    sys.exit(1)

# default settings

MaxFileSize = 10 * 1024 * 1024  # 10MB
files = {'defaults': '#CONFIG_PREFIX#/default/ufw' }
debugging = False
disableChecks = False

# end default settings

def process_args():
    '''Process command line arguments'''
    action = ""
    rule = ""
    dryrun = False

    if len(sys.argv) > 1 and sys.argv[1].lower() == "--dry-run":
        dryrun = True
        sys.argv.remove("--dry-run")

    if len(sys.argv) < 2:
        printHelp()
        sys.exit(1)

    allowed_cmds = ['enable', 'disable', 'help', 'logging', 'status', 'version', 'allow', 'deny' ]

    if not sys.argv[1].lower() in allowed_cmds:
        printHelp()
        sys.exit(1)
    else:
        action = sys.argv[1].lower()

    if action == "logging":
        if len(sys.argv) < 3:
            printHelp()
            sys.exit(1)
        elif sys.argv[2].lower() == "off":
            action = "logging-off"
        elif sys.argv[2].lower() == "on":
            action = "logging-on"
        else:
            printHelp()
            sys.exit(1)

    if action == "allow" or action == "deny":
        if len(sys.argv) < 3:
            printHelp()
            sys.exit(1)
        
        if len(sys.argv) == 3:
            # simple rule
            tmp = sys.argv[2].split(':')
            if len(tmp) == 1:
                rule = ufwRule(action, "any", tmp[0])
            elif len(tmp) == 2:
                rule = ufwRule(action, tmp[1], tmp[0])
            else:
                printHelp()
                sys.exit(1)
        elif len(sys.argv) == 4:
            if sys.argv[2].lower() != "from" and sys.argv[2].lower() != "to":
                printHelp()
                sys.exit(1)
            tmp = sys.argv[3].split(':')
            if len(tmp) == 1:
                if sys.argv[2].lower() == "to":
                    rule = ufwRule(action, "any", "any", tmp[0])
                else:
                    rule = ufwRule(action, "any", "any", "0.0.0.0/0", "any", tmp[0])
            elif len(tmp) == 2:
                if sys.argv[2].lower() == "to":
                    rule = ufwRule(action, "any", tmp[1], tmp[0])
                else:
                    rule = ufwRule(action, "any", "any", "0.0.0.0/0", tmp[1], tmp[0])
            elif len(tmp) == 3:
                if sys.argv[2].lower() == "to":
                    rule = ufwRule(action, tmp[2], tmp[1], tmp[0])
                else:
                    rule = ufwRule(action, tmp[2], "any", "0.0.0.0/0", tmp[1], tmp[0])
            else:
                printHelp()
                sys.exit(1)
        elif len(sys.argv) == 7:
            if sys.argv[3].lower() == sys.argv[5].lower():
                printHelp()
                sys.exit(1)
            if sys.argv[3].lower() != "from" and sys.argv[3].lower() != "to":
                printHelp()
                sys.exit(1)
            if sys.argv[5].lower() != "from" and sys.argv[5].lower() != "to":
                printHelp()
                sys.exit(1)

            if sys.argv[3].lower() == "from":
                rule.addSrc(sys.argv[4])
            else:
                rule.addDst(sys.argv[4])

            if sys.argv[5].lower() == "from":
                rule.addSrc(sys.argv[6])
            else:
                rule.addDst(sys.argv[6])
        else:
            printHelp()
            sys.exit(1)

    return (action, rule, dryrun)
    
def printHelp():
    '''Help message'''
    print '''
Usage: ''' + programName + ''' COMMAND

Commands:
  enable			Enables the firewall
  disable			Disables the fireall
  logging ARG			set logging to ON or OFF
  allow [from ADDR] [to ADDR]	allow packets to/from ADDR
  deny [from ADDR] [to ADDR]	deny packets to/from ADDR
  status			show firewall status
  version			display version information
'''

def openFileRead(f):
    size = 0
    try:
        size = os.stat(f)[ST_SIZE]
    except:
        raise

    if size > MaxFileSize:
        raise ufwError("'" + f + "' is too big")

    try:
        orig = open(f, 'r')
    except:
        raise

    return orig

def openFiles(f):
    '''Opens the specified file read-only'''
    orig = openFileRead(f)

    try:
        (tmp, tmpname) = mkstemp()
    except:
        orig.close()
        raise

    return { "orig": orig, "origname": f, "tmp": tmp, "tmpname": tmpname }

def closeFiles(fns, update = True):
    '''Closes the specified files (as returned by openFiles), and update
       original file with the temporary file'''
    fns['orig'].close()
    os.close(fns['tmp'])

    if update:
        try:
            shutil.copystat(fns['origname'], fns['tmpname'])
            shutil.copy(fns['tmpname'], fns['origname'])
        except:
            raise

    try:
        os.unlink(fns['tmpname'])
    except:
        raise


def cmd(command):
    '''Try to execute given command (array)'''
    cmd = ' '.join(command)
    try:
        rc = subprocess.call(cmd, shell=True)
    except OSError, e:
        return [127, str(e)]

    return rc

def cmdPipe(command1, command2):
    '''Try to pipe command1 (array) into command2 (array)'''
    try:
        sp1 = subprocess.Popen(command1, stdout=subprocess.PIPE)
        sp2 = subprocess.Popen(command2, stdin=sp1.stdout)
    except OSError, e:
        return [127, str(e)]

    output = sp2.communicate()[0]
    return sp2.returncode

def error(msg):
    print >> sys.stderr, "ERROR: " + msg
    sys.exit(1)

def warn(msg):
    print >> sys.stderr, "WARN: " + msg

def debug(msg):
    if debugging:
        print >> sys.stderr, "DEBUG: " + msg

#
# Classes
#
class ufwError(Exception):
    '''Represents ufw exceptions'''
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class ufwRule:
    '''Represents network rules'''
    def __init__(self, action, protocol, dport="any", dst="0.0.0.0/0", sport="any", src="0.0.0.0/0"):
        try:
            self.setAction(action)
            self.setProtocol(protocol)
            self.setPort(dport)
            self.setPort(sport, "src")
            self.setSrc(src)
            self.setDst(dst)
        except:
            raise

    def _validAddress(self, addr):
        # quick test
        if not re.match('^[0-9./]+$', addr):
            return False

        net = addr.split('/')

        if len(net) > 2:
            return False
        elif len(net) == 2:
            # check netmask '/'
            # TODO check 255.255.255.0 type netmasks
            if int(net[1]) < 0 or int(net[1]) > 32:
                return False

        ip = net[0].split('.')
        if len(ip) != 4:
            return False
        for i in ip:
            if not i or int(i) < 0 or int(i) > 255:
                return False
        return True

    def setAction(self, action):
        if action == "allow":
            self.action = action
        else:
            self.action = "deny"

    def setPort(self, port, loc="dst"):
        # quick test
        if port == "any" or re.match('^\d+$', port):
            pass
        else:
            raise ufwError("Bad port " + port)

        if port != "any":
            if int(port) < 1 or int(port) > 65535:
                raise ufwError("Bad port")

        if loc == "src":
            self.sport = port
        else:
            self.dport = port

    def setProtocol(self, protocol):
        # for now, just tcp, udp and any
        if protocol == "tcp" or protocol == "udp" or protocol == "any":
            self.protocol = protocol
        else:
            raise ufwError("Unsupported protocol" + protocol)

    def setSrc(self, addr):
        if not self._validAddress(addr):
            raise ufwError("Bad source address")
        self.src = addr

    def setDst(self, addr):
        if not self._validAddress(addr):
            raise ufwError("Bad destination address")
        self.dst = addr

    def match(self, x, y):
        '''Check if rules match'''
        # Return codes:
        #   0	match
        #   1	no match
        #  -1	match all but action
        if x.dport != y.dport:
            return 1
        if x.sport != y.sport:
            return 1
        if x.protocol != y.protocol:
            return 1
        if x.src != y.src:
            return 1
        if x.dst != y.dst:
            return 1
        
        if x.action == y.action:
            return 0
        return -1

class ufwBackend:
    '''Interface for backends'''
    def __init__(self, name, d):
        self.defaults = {}
        self.name = name
        self.dryrun = d
        self.rules = []
        try:
            self._doChecks()
            self._getDefaults()
        except:
            raise

    def _isEnabled(self):
        if self.defaults.has_key('enabled') and self.defaults['enabled'] == 'yes':
            return True
        return False

    def _useIPV6(self):
        if self.defaults.has_key('ipv6') and self.defaults['ipv6'] == 'yes':
            return True
        return False

    def _doChecks(self):
        '''perform basic security checks'''
        if disableChecks:
            warn("Checks disabled")
            return True
        # Does the following checks:
        #       is setuid or setgid (for non-Linux systems)
        #       checks that script is owned by root
        #       checks that every component in absolute path are owned by root
        #       checks that every component of absolute path are not a symlink
        #       warn if script is group writable
        #       warn if part of script path is group writable
        #

        # Doing this at the beginning causes a race condition with later
        # operations that don't do these checks.  However, if the user running
        # this script is root, then need to be root to exploit the race 
        # condition (and you are hosed anyway...)

        # not needed on Linux, but who knows the places we will go...
        if os.getuid() != os.geteuid():
            raise ufwError("ERROR: this script should not be SUID")
        if os.getgid() != os.getegid():
            raise ufwError("ERROR: this script should not be SGID")
        uid = os.getuid()

        if uid != 0:
            raise ufwError("You need to be root to run this script")

        pat = re.compile(r'^\.')
        for path in files.values() + [ os.path.abspath(sys.argv[0]) ]:
            while True:
                debug("Checking " + path)
                if pat.search(os.path.basename(path)):
                    raise ufwError("found hidden directory in path: " + path)

                try:
                    statinfo = os.stat(path)
                    mode = statinfo[ST_MODE]
                except:
                    raise

                if os.path.islink(path):
                    raise ufwError("found symbolic link in path: " + path)
                if statinfo.st_uid != 0:
                    raise ufwError("uid is " + str(uid) + " but '" + path + "' is owned by " + str(statinfo.st_uid))
                if mode & S_IWOTH:
                    raise ufwError(path + " is world writable!")
                if mode & S_IWGRP:
                    warn(path + " is group writable")

                # exit loop after processing '/'
                if path == "/":
                    break

                path = os.path.dirname(path)
                if not path:
                    raise

        for f in files:
            if not os.path.isfile(files[f]):
                raise ufwError("'" + f + "' file '" + files[f] + "' does not exist")

    def _getDefaults(self):
        '''Get all settings from defaults file'''
        orig = openFileRead(files['defaults'])

        self.defaults = {}
        lines = orig.readlines()
        pat = re.compile(r'^\w+=\w+')
        for line in lines:
            if pat.search(line):
                tmp = re.split(r'=', line.strip())
                self.defaults[tmp[0].lower()] = tmp[1].lower()

        orig.close()

    def setDefault(self, f, opt, value):
        '''Set option in defaults file'''
        try:
            fns = openFiles(f)
        except:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()
        pat = re.compile(r'^' + opt + '=')
        for line in lines:
            if pat.search(line):
                os.write(fd, opt + "=" + value + "\n")
            else:
                os.write(fd, line)
    
        closeFiles(fns)

    # API overrides
    def getLogLevel(self):
        raise ufwError("ufwBackend.getLogLevel: need to override getLogLevel")

    def setLogLevel(self, level):
        raise ufwError("ufwBackend.setLogLevel: need to override setLogLevel")

    def getStatus(self):
        raise ufwError("ufwBackend.getStatus: need to override getStatus")

    def setRule(self, rule):
        raise ufwError("ufwBackend.setRule: need to override getStatus")

    def startFirewall(self):
        raise ufwError("ufwBackend.startFirewall: need to override startFirewall")

    def stopFirewall(self):
        raise ufwError("ufwBackend.stopFirewall: need to override stopFirewall")

class iptBackend(ufwBackend):
    def __init__(self, d):
	files['rules'] = '#CONFIG_PREFIX#/ufw/ufw.rules'
        ufwBackend.__init__(self, "iptables", d)

    def getLogLevel(self):
        '''show current log level'''
        print "getLogLevel: TODO"

    def setLogLevel(self, level):
        '''set log level'''
        commentStr = "# ufw_" + programName + " #"
        try:
            fns = openFiles(files['rules'])
        except:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()

        pat = re.compile(r'^-.*\sLOG\s')
        if level == "on":
            pat = re.compile(r'^#.*\sLOG\s')

        if not self.dryrun:
            for line in lines:
                if pat.search(line):
                    if level == "off":
                        os.write(fd, commentStr + ' ' + line)
                    else:
                        pat_comment = re.compile(r"^" + commentStr + "\s*")
                        os.write(fd, pat_comment.sub('', line))
                else:
                    os.write(fd, line)
    
        if level == "off":
            print "logging disabled"
        else:
            print "logging enabled"

        closeFiles(fns)

    def getStatus(self):
        '''show current status'''
        if dryrun:
            print "> iptables -L -n"
            if self._useIPV6():
                print "> ip6tables -L -n"
            return

        rc = cmd(['iptables', '-L', '-n'])
        if rc != 0:
            raise ufwError("problem running iptables")
        if self._useIPV6():
            rc = cmd(['ip6tables', '-L', '-n'])
            if rc != 0:
                raise ufwError("problem running ip6tables")

    def stopFirewall(self):
        '''stop the firewall'''
        openconf = '''*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
'''
        if dryrun:
            print "> echo\n" + openconf + "> | iptables-restore"
            if self._useIPV6():
                print "> echo\n" + openconf + "> | ip6tables-restore"
            return

        try:
            (tmp, tmpname) = mkstemp()
        except:
            raise
        os.write(tmp, openconf)
        os.close(tmp)

        rc = cmdPipe(['cat', tmpname], ['iptables-restore'])
        if rc != 0:
            raise ufwError("problem running iptables")

        if self._useIPV6():
            rc = cmdPipe(['cat', tmpname], ['ip6tables-restore'])
            if rc != 0:
                raise ufwError("problem running ip6tables")

    def startFirewall(self):
        '''start the firewall'''
        if dryrun:
            print "> cat " + files['rules'] + " | iptables-restore"
        else:
            rc = cmdPipe(['cat', files['rules']], ['iptables-restore'])
            if rc != 0:
                raise ufwError("problem running iptables")

        if self._useIPV6():
            if dryrun:
                print "> cat " + files['rules'] + " | ip6tables-restore"
            else:
                rc = cmdPipe(['cat', files['rules']], ['ip6tables-restore'])
                if rc != 0:
                    raise ufwError("problem running ip6tables")
        else:
            # just enable ipv6 on loopback
            ipv6conf = '''*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

-A INPUT -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT

COMMIT
'''
            if dryrun:
                print "> echo\n" + ipv6conf + "> | ip6tables-restore"
            else:
                rc = cmdPipe(['echo', ipv6conf], ['ip6tables-restore'])
                if rc != 0:
                    # don't error here, as the user may have disabled ipv6
                    # and doesn't have ipv6 support
                    warn("problem running ip6tables")

    def _readRules(self):
        '''Read in rules add via ufw'''
        print "TODO"

    def _writeRules(self):
        '''Write out new rules file'''
        for r in self.rules:
            print "-A INPUT",
            if r.protocol != "any":
                print "-p " + r.protocol,
            if r.src != "0.0.0.0/0":
                print "-s " + r.src,
            if r.sport != "any":
                print "--sport " + r.sport,
            if r.dst != "0.0.0.0/0":
                print "-d " + r.dst,
            if r.dport != "any":
                print "--dport " + r.dport,
            if r.action == "allow":
                print "-j ACCEPT"
            else:
                print "-j DENY"

    def setRule(self, rule):
        '''Update firewall with rule'''
        self._readRules()
        i = 0
        for r in self.rules:
            ret = ufwRule.match(r, rule)
            if ret == 0:
                # rule already exists, so do nothing
                return
            if ret < 0:
                # matches all but action
                self.rules[i] = rule
                break
            i += 1
        # add rule to the end
        self.rules.append(rule)
        self._writeRules()

class ufwFrontend:
    '''UI'''
    def __init__(self, be):
        self.backend = be

    def setEnabled(self, enabled):
        '''set status of #CONFIG_PREFIX#/defaults/ufw'''
        try:
            if enabled:
                if not self.backend._isEnabled():
                    self.backend.setDefault(files['defaults'], "ENABLED", "yes")
                self.backend.startFirewall()
                print "firewall enabled"
            else:
                if self.backend._isEnabled():
                    self.backend.setDefault(files['defaults'], "ENABLED", "no")
                self.backend.stopFirewall()
                print "firewall disabled"
        except ufwError, e:
            error(e.value)

    def setLogLevel(self, level):
        '''set log level'''
        try:
            self.backend.setLogLevel(level)
        except ufwError, e:
            error(e.value)

    def getStatus(self):
        '''show status of firewall'''
        try:
            self.backend.getStatus()
        except ufwError, e:
            error(e.value)

    def setRule(self, rule):
        '''set rule'''
        try:
            self.backend.setRule(rule)
        except ufwError, e:
            error(e.value)

#
# MAIN SCRIPT STARTS HERE
#
action = ""
rule = ""
dryrun = False
try:
    (action, rule, dryrun) = process_args()
except ufwError, e:
    error(e.value)

if action == "help":
    printHelp()
    sys.exit(0)
elif action == "version":
    print programName + " " + version
    print "Copyright (C) 2007 Canonical Ltd."
    print programName + " is free software, covered by the GNU General Public License, and you are"
    print "welcome to change it and/or distribute copies of it under certain conditions."
    sys.exit(0)

try:
    ufw = ufwFrontend(iptBackend(dryrun))
except ufwError, e:
    error(e.value)
except:
    raise

if action == "logging-on":
    ufw.setLogLevel("on")
elif action == "logging-off":
    ufw.setLogLevel("off")
elif action == "status":
    ufw.getStatus()
elif action == "enable":
    ufw.setEnabled(True)
elif action == "disable":
    ufw.setEnabled(False)
elif action == "allow" or action == "deny":
    ufw.setRule(rule)

sys.exit(0)

