#! /usr/bin/env python
#
# ufw: front-end for Linux firewalling
#
# Copyright (C) 2007 Canonical <jamie@ubuntu.com>
#
#    ufw is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published
#    by the Free Software Foundation; either version 2 of the License,
#    or (at your option) any later version.
#
#    ufw is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with ufw; if not, write to the Free Software Foundation,
#    Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

import os, re, shutil, stat, subprocess, sys
from stat import *
from tempfile import mkstemp

version = "0.1"
programName = os.path.basename(sys.argv[0])

# make sure we are at least version 2.4
if sys.version_info[0] < 2 or sys.version_info[1] < 4:
    print >> sys.stderr, programName + ": Need at least python 2.4\n"
    sys.exit(1)

# default settings
MaxFileSize = 10 * 1024 * 1024  # 10MB

#files = {'defaults': '/tmp/ufw/etc/default/ufw',
#	'rules': '/tmp/ufw/etc/ufw/ufw.rules' }
files = {'defaults': '#CONFIG_PREFIX#/default/ufw',
	'rules': '#CONFIG_PREFIX#/ufw/ufw.rules' }

debug = False

# end default settings

def process_args():
    '''Process command line arguments'''
    action = ""

    if len(sys.argv) < 2:
        printHelp()
        sys.exit(1)

    allowed_cmds = ['enable', 'disable', 'help', 'load', 'logging', 'status', 'version']

    if not sys.argv[1].lower() in allowed_cmds:
        printHelp()
        sys.exit(1)
    else:
        action = sys.argv[1].lower()

    if action == "logging":
        if len(sys.argv) < 3:
            printHelp()
            sys.exit(1)
        elif sys.argv[2].lower() == "off":
            action = "logging-off"
        elif sys.argv[2].lower() == "on":
            action = "logging-on"
        else:
            printHelp()
            sys.exit(1)

    return action
    
def printHelp():
    '''Help message'''
    print '''
Usage: ''' + programName + ''' COMMAND

Commands:
  enable		Enables the firewall
  disable		Disables the fireall
  logging ARG		set logging to ON or OFF
  status		show firewall status
  version		display version information
'''

def openFileRead(f):
    size = 0
    try:
        size = os.stat(f)[ST_SIZE]
    except:
        raise

    if size > MaxFileSize:
        raise ufwError("'" + f + "' is too big")

    try:
        orig = open(f, 'r')
    except:
        raise

    return orig

def openFiles(f):
    '''Opens the specified file read-only'''
    orig = openFileRead(f)

    try:
        (tmp, tmpname) = mkstemp()
    except:
        orig.close()
        raise

    return { "orig": orig, "origname": f, "tmp": tmp, "tmpname": tmpname }

def closeFiles(fns, update = True):
    '''Closes the specified files (as returned by openFiles), and update
       original file with the temporary file'''
    fns['orig'].close()
    os.close(fns['tmp'])

    if update:
        try:
            shutil.copystat(fns['origname'], fns['tmpname'])
            shutil.copy(fns['tmpname'], fns['origname'])
        except:
            raise

    try:
        os.unlink(fns['tmpname'])
    except:
        raise


def cmd(command):
    '''Try to execute given command (array)'''
    cmd = ' '.join(command)
    try:
        rc = subprocess.call(cmd, shell=True)
    except OSError, e:
        return [127, str(e)]

    return rc

def cmdPipe(command1, command2):
    '''Try to pipe command1 (array) into command2 (array)'''
    try:
        sp1 = subprocess.Popen(command1, stdout=subprocess.PIPE)
        sp2 = subprocess.Popen(command2, stdin=sp1.stdout)
    except OSError, e:
        return [127, str(e)]

    output = sp2.communicate()[0]
    return sp2.returncode

def error(msg):
    print >> sys.stderr, "ERROR: " + msg
    sys.exit(1)

def warn(msg):
    print >> sys.stderr, "WARN: " + msg

#
# Classes
#
class ufwError(Exception):
    '''Represents ufw exceptions'''
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

class ufwBackend:
    '''Interface for backends'''
    def __init__(self, name):
        self.defaults = {}
        self.name = name
        self._doChecks()
        self._getDefaults()

    def _isEnabled(self):
        if self.defaults.has_key('enabled') and self.defaults['enabled'] == 'yes':
            return True
        return False

    def _useIPV6(self):
        if self.defaults.has_key('ipv6') and self.defaults['ipv6'] == 'yes':
            return True
        return False

    def _doChecks(self):
        '''perform basic security checks'''
        #warn("ufwBackend.doChecks: TODO")
        for f in files:
            if not os.path.isfile(files[f]):
                raise ufwError("'" + f + "' file '" + files[f] + "' does not exist")

    def _getDefaults(self):
        '''Get all settings from defaults file'''
        orig = openFileRead(files['defaults'])

        self.defaults = {}
        lines = orig.readlines()
        pat = re.compile(r'^\w+=\w+')
        for line in lines:
            if pat.search(line):
                tmp = re.split(r'=', line.strip())
                self.defaults[tmp[0].lower()] = tmp[1].lower()

        orig.close()

    def setDefault(self, f, opt, value):
        '''Set option in defaults file'''
        try:
            fns = openFiles(f)
        except:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()
        pat = re.compile(r'^' + opt + '=')
        for line in lines:
            if pat.search(line):
                os.write(fd, opt + "=" + value + "\n")
            else:
                os.write(fd, line)
    
        closeFiles(fns)

    # API overrides
    def getLogLevel(self):
        raise ufwError("ufwBackend.getLogLevel: need to override getLogLevel")

    def setLogLevel(self, level):
        raise ufwError("ufwBackend.setLogLevel: need to override setLogLevel")

    def getStatus(self):
        raise ufwError("ufwBackend.getStatus: need to override getStatus")

    def startFirewall(self):
        raise ufwError("ufwBackend.startFirewall: need to override startFirewall")

    def stopFirewall(self):
        raise ufwError("ufwBackend.stopFirewall: need to override stopFirewall")

class iptBackend(ufwBackend):
    def __init__(self):
        ufwBackend.__init__(self, "iptables")
    def getLogLevel(self):
        '''show current log level'''
        print "getLogLevel: TODO"

    def setLogLevel(self, level):
        '''set log level'''
        commentStr = "# ufw_" + programName + " #"
        try:
            fns = openFiles(files['rules'])
        except:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()

        pat = re.compile(r'^-.*\sLOG\s')
        if level == "on":
            pat = re.compile(r'^#.*\sLOG\s')

        for line in lines:
            if pat.search(line):
                if level == "off":
                    os.write(fd, commentStr + ' ' + line)
                else:
                    pat_comment = re.compile(r"^" + commentStr + "\s*")
                    os.write(fd, pat_comment.sub('', line))
            else:
                os.write(fd, line)
    
        if level == "off":
            print "logging disabled"
        else:
            print "logging enabled"

        closeFiles(fns)

    def getStatus(self):
        '''show current status'''
        rc = cmd(['iptables', '-L', '-n'])
        if rc != 0:
            error("problem running iptables")
        if self._useIPV6():
            rc = cmd(['ip6tables', '-L', '-n'])
            if rc != 0:
                error("problem running ip6tables")

    def stopFirewall(self):
        '''stop the firewall'''
        openconf = '''*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
'''
        try:
            (tmp, tmpname) = mkstemp()
        except:
            raise
        os.write(tmp, openconf)
        os.close(tmp)

        rc = cmdPipe(['cat', tmpname], ['iptables-restore'])
        if rc != 0:
            error("problem running iptables")

        if self._useIPV6():
            rc = cmdPipe(['cat', tmpname], ['ip6tables-restore'])
            if rc != 0:
                error("problem running ip6tables")

    def startFirewall(self):
        '''start the firewall'''
        rc = cmdPipe(['cat', files['rules']], ['iptables-restore'])
        if rc != 0:
            error("problem running iptables")

        if self._useIPV6():
            rc = cmdPipe(['cat', files['rules']], ['ip6tables-restore'])
            if rc != 0:
                error("problem running ip6tables")
        else:
            # just enable ipv6 on loopback
            ipv6conf = '''*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

-A INPUT -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT

COMMIT
'''
            rc = cmdPipe(['echo', ipv6conf], ['ip6tables-restore'])
            if rc != 0:
                # don't error here, as the user may have disabled ipv6
                # and doesn't have ipv6 support
                warn("problem running ip6tables")

class ufwFrontend:
    '''UI'''
    def __init__(self, be):
        self.backend = be

    def setEnabled(self, enabled):
        '''set status of #CONFIG_PREFIX#/defaults/ufw'''
        if enabled:
            if not self.backend._isEnabled():
                self.backend.setDefault(files['defaults'], "ENABLED", "yes")
            self.backend.startFirewall()
            print "firewall enabled"
        else:
            if self.backend._isEnabled():
                self.backend.setDefault(files['defaults'], "ENABLED", "no")
            self.backend.stopFirewall()
            print "firewall disabled"

    def setLogLevel(self, level):
        '''set log level'''
        self.backend.setLogLevel(level)

    def getStatus(self):
        '''show status of firewall'''
        self.backend.getStatus()

    def load(self):
        '''load the firewall'''
        if self.backend._isEnabled():
            self.backend.startFirewall()
        else:
            warn("Firewall not enabled. Exiting")

#
# MAIN SCRIPT STARTS HERE
#
action = ""
try:
    action = process_args()
except ufwError, e:
    print >> sys.stderr, e.value + "\n"
    sys.exit(1)

ufw = ufwFrontend(iptBackend())

# do action
if action == "help":
    printHelp()
    sys.exit(0)
elif action == "version":
    print programName + " " + version
    print "Copyright (C) 2007 Canonical Ltd."
    print programName + " is free software, covered by the GNU General Public License, and you are"
    print "welcome to change it and/or distribute copies of it under certain conditions."
    sys.exit(0)
elif action == "logging-on":
    ufw.setLogLevel("on")
elif action == "logging-off":
    ufw.setLogLevel("off")
elif action == "status":
    ufw.getStatus()
elif action == "enable":
    ufw.setEnabled(True)
elif action == "disable":
    ufw.setEnabled(False)
elif action == "load":
    ufw.load()

sys.exit(0)

