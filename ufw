#! /usr/bin/env python
#
# ufw: front-end for Linux firewalling
#
# Copyright (C) 2008 Canonical Ltd.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License version 3,
#    as published by the Free Software Foundation.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import re
import shutil
import stat
from stat import *
import subprocess
import sys
from tempfile import mkstemp

version = "0.0"
programName = os.path.basename(sys.argv[0])

# Make sure we are at least version 2.4
if sys.version_info[0] < 2 or sys.version_info[1] < 5:
    print >> sys.stderr, programName + ": Need at least python 2.5\n"
    sys.exit(1)

# These are default settings
max_file_size = 10 * 1024 * 1024  # 10MB
files = {'defaults': '#CONFIG_PREFIX#/default/ufw' }
debugging = False
disable_checks = False


def process_args():
    '''Process command line arguments'''
    action = ""
    rule = ""
    dryrun = False

    if len(sys.argv) > 1 and sys.argv[1].lower() == "--dry-run":
        dryrun = True
        sys.argv.remove("--dry-run")

    remove = False
    if len(sys.argv) > 1 and sys.argv[1].lower() == "delete":
        remove = True
        sys.argv.remove("delete")

    if len(sys.argv) < 2:
        print_help()
        sys.exit(1)

    allowed_cmds = ['enable', 'disable', 'help', 'default', 'logging', 
                    'status', 'version', 'allow', 'deny' ]

    if not sys.argv[1].lower() in allowed_cmds:
        print_help()
        sys.exit(1)
    else:
        action = sys.argv[1].lower()

    if action == "logging":
        if len(sys.argv) < 3:
            print_help()
            sys.exit(1)
        elif sys.argv[2].lower() == "off":
            action = "logging-off"
        elif sys.argv[2].lower() == "on":
            action = "logging-on"
        else:
            print_help()
            sys.exit(1)

    if action == "default":
        if len(sys.argv) < 3:
            print_help()
            sys.exit(1)
        elif sys.argv[2].lower() == "deny":
            action = "default-deny"
        elif sys.argv[2].lower() == "allow":
            action = "default-allow"
        else:
            print_help()
            sys.exit(1)

    if action == "allow" or action == "deny":
        if len(sys.argv) < 3 or len(sys.argv) > 8:
            print_help()
            sys.exit(1)
        
        rule = UFWRule(action, "any", "any")
        if remove:
            rule.remove = remove
        if len(sys.argv) == 3:
            try:
                (port, proto) = parse_port_proto(sys.argv[2])
                rule.set_protocol(proto)
                rule.set_port(port, "dst")
            except UFWError:
                raise UFWError("Bad port")
        else:
            # position in argv of 'from' or 'to'
            found_from = -1
            found_to = -1
            i = 0
            for arg in sys.argv:
                if re.match("from", arg.lower()):
                     found_from = i
                elif re.match("to", arg.lower()):
                     found_to = i
                i += 1
            
            # make sure have from and to
            if len(sys.argv) >= 6:
                if found_from < 0 or found_to < 0:
                    print_help()
                    sys.exit(1)
            else:
                if found_from < 0 and found_to < 0:
                    print_help()
                    sys.exit(1)

            # TODO: parsing 'to' and 'from' could be prettier...
            # process from
            pos = found_from
            if pos > 0:
                if pos == len(sys.argv) - 1:
                    raise UFWError("Bad address or port")
                if pos < len(sys.argv) - 1:
                    try:
                        if valid_address(sys.argv[pos + 1]):
                            rule.set_src(sys.argv[pos + 1])
                        else:
                            (port, proto) = parse_port_proto(sys.argv[pos + 1])
                            if rule.protocol != "any" and \
                               rule.protocol != proto:
                                raise UFWError("from/to protocol mismatch")
                            rule.set_protocol(proto)
                            rule.set_port(port, "src")
                    except UFWError:
                        raise
                if pos < len(sys.argv) - 2 and pos + 2 != found_to:
                    try:
                        (port, proto) = parse_port_proto(sys.argv[pos + 2])
                        if rule.protocol != "any" and rule.protocol != proto:
                            raise UFWError("from/to protocol mismatch")
                        rule.set_protocol(proto)
                        rule.set_port(port, "src")
                    except UFWError:
                        raise
            # process to
            pos = found_to
            if pos > 0:
                if pos == len(sys.argv) - 1:
                    raise UFWError("Bad address or port")
                if pos < len(sys.argv) - 1:
                    try:
                        if valid_address(sys.argv[pos + 1]):
                            rule.set_dst(sys.argv[pos + 1])
                        else:
                            (port, proto) = parse_port_proto(sys.argv[pos + 1])
                            if rule.protocol != "any" and \
                               rule.protocol != proto:
                                raise UFWError("from/to protocol mismatch")
                            rule.set_protocol(proto)
                            rule.set_port(port, "dst")
                    except UFWError:
                        raise
                if pos < len(sys.argv) - 2 and pos + 2 != found_from:
                    try:
                        (port, proto) = parse_port_proto(sys.argv[pos + 2])
                        if rule.protocol != "any" and rule.protocol != proto:
                            raise UFWError("from/to protocol mismatch")
                        rule.set_protocol(proto)
                        rule.set_port(port, "dst")
                    except UFWError:
                        raise


    return (action, rule, dryrun)
    

def parse_port_proto(str):
    '''Parse port or port and protocol'''
    port = ""
    proto = ""
    tmp = str.split(':')
    if len(tmp) == 1:
        port = tmp[0]
        proto = "any"
    elif len(tmp) == 2:
        port = tmp[0]
        proto = tmp[1]
    else:
        raise UFWError("Bad port/protocol")
    return (port, proto)


def valid_address(addr):
    '''Validate IPV4 address'''
    if not re.match('^[0-9./]+$', addr):
        return False

    net = addr.split('/')

    if len(net) > 2:
        return False
    elif len(net) == 2:
        # check netmask '/'
        # TODO check 255.255.255.0 type netmasks
        if int(net[1]) < 0 or int(net[1]) > 32:
            return False

    ip = net[0].split('.')
    if len(ip) != 4:
        return False
    for i in ip:
        if not i or int(i) < 0 or int(i) > 255:
            return False
    return True


def print_help():
    '''Print help message'''
    print '''
Usage: ''' + programName + ''' COMMAND

Commands:
  enable			Enables the firewall
  disable			Disables the fireall
  default ARG			set default policy to ALLOW or DENY
  logging ARG			set logging to ON or OFF
  allow|deny RULE		allow or deny RULE
  delete allow|deny RULE	delete the allow/deny RULE
  status			show firewall status
  version			display version information
'''

def open_file_read(f):
    '''Opens the specified file read-only'''
    size = 0
    try:
        size = os.stat(f)[ST_SIZE]
    except OSError, e:
        raise UFWError("Couldn't stat '" + f + "'")
    except Exception:
        raise

    if size > max_file_size:
        raise UFWError("'" + f + "' is too big")

    try:
        orig = open(f, 'r')
    except OSError, e:
        raise UFWError("Couldn't open '" + f + "' for reading")
    except Exception:
        raise

    return orig


def open_files(f):
    '''Opens the specified file read-only and a tempfile read-write.'''
    orig = open_file_read(f)

    try:
        (tmp, tmpname) = mkstemp()
    except Exception:
        orig.close()
        raise

    return { "orig": orig, "origname": f, "tmp": tmp, "tmpname": tmpname }


def close_files(fns, update = True):
    '''Closes the specified files (as returned by open_files), and update
       original file with the temporary file.
    '''
    fns['orig'].close()
    os.close(fns['tmp'])

    if update:
        try:
            shutil.copystat(fns['origname'], fns['tmpname'])
            shutil.copy(fns['tmpname'], fns['origname'])
        except Exception:
            raise

    try:
        os.unlink(fns['tmpname'])
    except OSError, e:
        raise


def cmd(command):
    '''Try to execute the given command.'''
    cmd = ' '.join(command)
    try:
        rc = subprocess.call(cmd, shell=True)
    except OSError, e:
        return [127, str(e)]

    return rc


def cmd_pipe(command1, command2):
    '''Try to pipe command1 into command2.'''
    try:
        sp1 = subprocess.Popen(command1, stdout=subprocess.PIPE)
        sp2 = subprocess.Popen(command2, stdin=sp1.stdout)
    except OSError, e:
        return [127, str(e)]

    output = sp2.communicate()[0]
    return sp2.returncode


def error(msg):
    '''Print error message and exit'''
    print >> sys.stderr, "ERROR: " + msg
    sys.exit(1)


def warn(msg):
    '''Print warning message'''
    print >> sys.stderr, "WARN: " + msg


def debug(msg):
    '''Print debug message'''
    if debugging:
        print >> sys.stderr, "DEBUG: " + msg

#
# Classes
#
class UFWError(Exception):
    '''This class represents ufw exceptions'''
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


class UFWRule:
    '''This class represents network rules'''
    def __init__(self, action, protocol, dport="any", dst="0.0.0.0/0",
                 sport="any", src="0.0.0.0/0"):
        try:
            self.set_action(action)
            self.set_protocol(protocol)
            self.set_port(dport)
            self.set_port(sport, "src")
            self.set_src(src)
            self.set_dst(dst)
            self.remove = False
        except UFWError:
            raise

    def __str__(self):
        str = "action:   " + self.action
        str = str + "\nprotocol: " + self.protocol
        str = str + "\ndst:      " + self.dst
        str = str + "\ndport:    " + self.dport
        str = str + "\nsrc:      " + self.src
        str = str + "\nsport:    " + self.sport
        return str

    def set_action(self, action):
        '''Sets action of the rule'''
        if action == "allow":
            self.action = action
        else:
            self.action = "deny"

    def set_port(self, port, loc="dst"):
        '''Sets port and location (destination or source) of the rule'''
        if port == "any" or re.match('^\d+$', port):
            pass
        else:
            raise UFWError("Bad port '" + port + "'")

        if port != "any":
            if int(port) < 1 or int(port) > 65535:
                raise UFWError("Bad port")

        if loc == "src":
            self.sport = port
        else:
            self.dport = port

    def set_protocol(self, protocol):
        '''Sets protocol of the rule'''
        if protocol == "tcp" or protocol == "udp" or protocol == "any":
            self.protocol = protocol
        else:
            raise UFWError("Unsupported protocol" + protocol)

    def set_src(self, addr):
        '''Sets source address of rule'''
        if not valid_address(addr):
            raise UFWError("Bad source address")
        self.src = addr

    def set_dst(self, addr):
        '''Sets destination address of rule'''
        if not valid_address(addr):
            raise UFWError("Bad destination address")
        self.dst = addr

    def match(x, y):
        '''Check if rules match
        Return codes:
          0  match
          1  no match
         -1  match all but action
	'''
        if x.dport != y.dport:
            debug("No match")
            return 1
        if x.sport != y.sport:
            debug("No match")
            return 1
        if x.protocol != y.protocol:
            debug("No match")
            return 1
        if x.src != y.src:
            debug("No match")
            return 1
        if x.dst != y.dst:
            debug("No match")
            return 1
        
        if x.action == y.action:
            debug("Found exact match")
            return 0
        debug("Found opposite match")
        return -1


class UFWBackend:
    '''Interface for backends'''
    def __init__(self, name, d):
        self.defaults = {}
        self.name = name
        self.dryrun = d
        self.rules = []
        try:
            self._do_checks()
            self._get_defaults()
            self._read_rules()
        except Exception:
            raise

    def _is_enabled(self):
        if self.defaults.has_key('enabled') and \
           self.defaults['enabled'] == 'yes':
            return True
        return False

    def _use_ipv6(self):
        if self.defaults.has_key('ipv6') and self.defaults['ipv6'] == 'yes':
            return True
        return False

    def _do_checks(self):
        '''Perform basic security checks:
        is setuid or setgid (for non-Linux systems)
        checks that script is owned by root
        checks that every component in absolute path are owned by root
        checks that every component of absolute path are not a symlink
        warn if script is group writable
        warn if part of script path is group writable

        Doing this at the beginning causes a race condition with later
        operations that don't do these checks.  However, if the user running
        this script is root, then need to be root to exploit the race 
        condition (and you are hosed anyway...)
        '''

        if disable_checks:
            warn("Checks disabled")
            return True

        # Not needed on Linux, but who knows the places we will go...
        if os.getuid() != os.geteuid():
            raise UFWError("ERROR: this script should not be SUID")
        if os.getgid() != os.getegid():
            raise UFWError("ERROR: this script should not be SGID")
        uid = os.getuid()

        if uid != 0:
            raise UFWError("You need to be root to run this script")

        pat = re.compile(r'^\.')
        for path in files.values() + [ os.path.abspath(sys.argv[0]) ]:
            while True:
                debug("Checking " + path)
                if pat.search(os.path.basename(path)):
                    raise UFWError("found hidden directory in path: " + path)

                try:
                    statinfo = os.stat(path)
                    mode = statinfo[ST_MODE]
                except OSError, e:
                    raise UFWError("Couldn't stat '" + f + "'")
                except Exception:
                    raise

                if os.path.islink(path):
                    raise UFWError("found symbolic link in path: " + path)
                if statinfo.st_uid != 0:
                    raise UFWError("uid is " + str(uid) + " but '" + path + \
                                   "' is owned by " + str(statinfo.st_uid))
                if mode & S_IWOTH:
                    raise UFWError(path + " is world writable!")
                if mode & S_IWGRP:
                    warn(path + " is group writable")

                if path == "/":
                    break

                path = os.path.dirname(path)
                if not path:
                    raise

        for f in files:
            if not os.path.isfile(files[f]):
                raise UFWError("'" + f + "' file '" + files[f] + \
                               "' does not exist")

    def _get_defaults(self):
        '''Get all settings from defaults file'''
        orig = open_file_read(files['defaults'])

        self.defaults = {}
        lines = orig.readlines()
        pat = re.compile(r'^\w+=\w+')
        for line in lines:
            if pat.search(line):
                tmp = re.split(r'=', line.strip())
                self.defaults[tmp[0].lower()] = tmp[1].lower()

        orig.close()

    def set_default(self, f, opt, value):
        '''Sets option in defaults file'''
        try:
            fns = open_files(f)
        except Exception:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()
        pat = re.compile(r'^' + opt + '=')
        for line in lines:
            if pat.search(line):
                os.write(fd, opt + "=" + value + "\n")
            else:
                os.write(fd, line)
    
        close_files(fns)

    # API overrides
    def get_loglevel(self):
        raise UFWError("UFWBackend.get_loglevel: need to override")

    def set_loglevel(self, level):
        raise UFWError("UFWBackend.set_loglevel: need to override")

    def set_default_policy(self, policy):
        raise UFWError("UFWBackend.set_default_policy: need to override")

    def get_status(self):
        raise UFWError("UFWBackend.get_status: need to override")

    def set_rule(self, rule):
        raise UFWError("UFWBackend.set_rule: need to override")

    def start_firewall(self):
        raise UFWError("UFWBackend.start_firewall: need to override")

    def stop_firewall(self):
        raise UFWError("UFWBackend.stop_firewall: need to override")


class UFWBackendIptables(UFWBackend):
    def __init__(self, d):
        files['rules'] = '#CONFIG_PREFIX#/ufw/ufw.rules'
        UFWBackend.__init__(self, "iptables", d)

    def get_loglevel(self):
        '''Show current log level of firewall'''
        print "get_loglevel: TODO"

    def set_default_policy(self, policy):
        '''Sets default policy of firewall'''
        try:
            fns = open_files(files['rules'])
        except Exception:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()

        pat = re.compile(r'^:INPUT\s+ACCEPT\s+\[0:0\]')
        if policy == "allow":
            pat = re.compile(r'^:INPUT\s+DROP\s+\[0:0\]')

        if not self.dryrun:
            for line in lines:
                if pat.search(line):
                    if policy == "allow":
                        os.write(fd, ":INPUT ACCEPT [0:0]\n")
                    else:
                        os.write(fd, ":INPUT DROP [0:0]\n")
                else:
                    os.write(fd, line)
    
        print "Default policy changed to '" + policy + "'"
        print "(be sure to update your rules accordingly)"

        if self.dryrun:
            close_files(fns, False)
        else:
            close_files(fns)

    def set_loglevel(self, level):
        '''Sets log level of firewall'''
        comment_str = "# " + programName + "_comment #"
        try:
            fns = open_files(files['rules'])
        except Exception:
            raise
        fd = fns['tmp']

        lines = fns['orig'].readlines()

        pat = re.compile(r'^-.*\sLOG\s')
        if level == "on":
            pat = re.compile(r'^#.*\sLOG\s')

        if not self.dryrun:
            for line in lines:
                if pat.search(line):
                    if level == "off":
                        os.write(fd, comment_str + ' ' + line)
                    else:
                        pat_comment = re.compile(r"^" + comment_str + "\s*")
                        os.write(fd, pat_comment.sub('', line))
                else:
                    os.write(fd, line)
    
        if level == "off":
            print "logging disabled"
        else:
            print "logging enabled"

        if self.dryrun:
            close_files(fns, False)
        else:
            close_files(fns)

    def get_status(self):
        '''Show current status of firewall'''
        if dryrun:
            print "> iptables -L -n"
            if self._use_ipv6():
                print "> ip6tables -L -n"
            return

        rc = cmd(['iptables', '-L', '-n'])
        if rc != 0:
            raise UFWError("problem running iptables")
        if self._use_ipv6():
            rc = cmd(['ip6tables', '-L', '-n'])
            if rc != 0:
                raise UFWError("problem running ip6tables")

    def stop_firewall(self):
        '''Stops the firewall'''
        openconf = '''*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
'''
        if dryrun:
            print "> echo\n" + openconf + "> | iptables-restore"
            if self._use_ipv6():
                print "> echo\n" + openconf + "> | ip6tables-restore"
            return

        try:
            (tmp, tmpname) = mkstemp()
        except Exception:
            raise
        os.write(tmp, openconf)
        os.close(tmp)

        rc = cmd_pipe(['cat', tmpname], ['iptables-restore'])
        if rc != 0:
            raise UFWError("problem running iptables")

        if self._use_ipv6():
            rc = cmd_pipe(['cat', tmpname], ['ip6tables-restore'])
            if rc != 0:
                raise UFWError("problem running ip6tables")

    def start_firewall(self):
        '''Starts the firewall'''
        if dryrun:
            print "> cat ufw.rules | iptables-restore"
        else:
            rc = cmd_pipe(['cat', files['rules']], ['iptables-restore'])
            if rc != 0:
                raise UFWError("problem running iptables")

        if self._use_ipv6():
            if dryrun:
                print "> cat ufw.rules | ip6tables-restore"
            else:
                rc = cmd_pipe(['cat', files['rules']], ['ip6tables-restore'])
                if rc != 0:
                    raise UFWError("problem running ip6tables")
        else:
            # just enable ipv6 on loopback
            ipv6conf = '''*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

-A INPUT -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT

COMMIT
'''
            if dryrun:
                print "> echo\n" + ipv6conf + "> | ip6tables-restore"
            else:
                rc = cmd_pipe(['echo', ipv6conf], ['ip6tables-restore'])
                if rc != 0:
                    # don't error here, as the user may have disabled ipv6
                    # and doesn't have ipv6 support
                    warn("problem running ip6tables")

    def _read_rules(self):
        '''Read in rules that were added by ufw.'''
        orig = open_file_read(files['rules'])

        lines = orig.readlines()
        pat_tuple = re.compile(r'^### DO NOT DELETE OR MODIFY: tuple ###\s*')
        for line in lines:
            if pat_tuple.match(line):
                tuple = pat_tuple.sub('', line)
                tmp = re.split(r'\s+', tuple.strip())
                if len(tmp) != 6:
                    warn("Skipping malformed tuple (bad length): " + tuple)
                else:
                    try:
                        rule = UFWRule(tmp[0], tmp[1], tmp[2], tmp[3], tmp[4],
                                       tmp[5])
                        self.rules.append(rule)
                    except UFWError:
                        warn("Skipping malformed tuple: " + tuple)

        orig.close()

    def _write_rules(self):
        '''Write out new rules'''
        try:
            fns = open_files(files['rules'])
        except Exception:
            raise

        if self.dryrun:
            fd = sys.stdout.fileno()
        else:
            fd = fns['tmp']

        lines = fns['orig'].readlines()
        pat_start = re.compile(r'^### DO NOT DELETE: rules start ###')
        pat_end = re.compile(r'^### DO NOT DELETE: rules end ###')
        in_rules = False
        for line in lines:
            if pat_start.match(line):
                os.write(fd, line)
                in_rules = True
            elif in_rules and pat_end.match(line):
                for r in self.rules:
                    str = "-A INPUT"

                    # protocol is handled below
                    str += " -p " + r.protocol
                    if r.dst != "0.0.0.0/0":
                        str += " -d " + r.dst
                    if r.dport != "any":
                        str += " --dport " + r.dport
                    if r.src != "0.0.0.0/0":
                        str += " -s " + r.src
                    if r.sport != "any":
                        str += " --sport " + r.sport
                    if r.action == "allow":
                        str += " -j ACCEPT\n"
                    else:
                        str += " -j DROP\n"

                    os.write(fd, "\n### DO NOT DELETE OR MODIFY: tuple ###" + \
                                 " %s %s %s %s %s %s\n" % (r.action, \
                                 r.protocol, r.dport, r.dst, r.sport, r.src))
                    if r.protocol == "any":
                        pat = re.compile(r'-p any ')
                        if r.sport != "any" or r.dport != "any":
                            os.write(fd, pat.sub('-p tcp ', str))
                            os.write(fd, pat.sub('-p udp ', str))
                        else:
                            os.write(fd, pat.sub('', str))
                    else:
                        os.write(fd, str)
                os.write(fd, "\n### DO NOT DELETE: rules end ###\n")
                in_rules = False
            elif in_rules:
                continue
            else:
                if not self.dryrun:
                    os.write(fd, line)
        if self.dryrun:
            close_files(fns, False)
        else:
            close_files(fns)

    def set_rule(self, rule):
        '''Updates firewall with rule'''
        newrules = []
        added = False
        for r in self.rules:
            ret = UFWRule.match(r, rule)
            if ret == 0 and not added:
                # If find the rule, add it if it's not to be removed, otherwise
                # skip it.
                added = True
                if not rule.remove:
                    newrules.append(rule)
            elif ret < 0 and not rule.remove:
                # If only the action is different, replace the rule if it's not
                # to be removed.
                added = True
                newrules.append(rule)
            else:
                newrules.append(r)

        # Add rule to the end if it was not already added.
        if not added and not rule.remove:
            newrules.append(rule)

        self.rules = newrules
        self._write_rules()


class UFWFrontend:
    '''UI'''
    def __init__(self, be):
        self.backend = be

    def set_enabled(self, enabled):
        '''Toggles ENABLED state in of #CONFIG_PREFIX#/defaults/ufw'''
        try:
            if enabled:
                if not self.backend._is_enabled():
                    self.backend.set_default(files['defaults'], \
                                             "ENABLED", "yes")
                self.backend.start_firewall()
                print "firewall enabled"
            else:
                if self.backend._is_enabled():
                    self.backend.set_default(files['defaults'], "ENABLED", \
                                             "no")
                self.backend.stop_firewall()
                print "firewall disabled"
        except UFWError, e:
            error(e.value)

    def set_default_policy(self, policy):
        '''Sets default policy of firewall'''
        try:
            self.backend.set_default_policy(policy)
            if self.backend._is_enabled():
                self.backend.start_firewall()
        except UFWError, e:
            error(e.value)

    def set_loglevel(self, level):
        '''Sets log level of firewall'''
        try:
            self.backend.set_loglevel(level)
            if self.backend._is_enabled():
                self.backend.start_firewall()
        except UFWError, e:
            error(e.value)

    def get_status(self):
        '''Shows status of firewall'''
        try:
            self.backend.get_status()
        except UFWError, e:
            error(e.value)

    def set_rule(self, rule):
        '''Updates firewall with rule'''
        try:
            self.backend.set_rule(rule)
            if self.backend._is_enabled():
                self.backend.start_firewall()
                print "rules updated and firewall reloaded"
            else:
                print "rules updated"
                
        except UFWError, e:
            error(e.value)


# Execution starts here
action = ""
rule = ""
dryrun = False
try:
    (action, rule, dryrun) = process_args()
except UFWError, e:
    error(e.value)

if action == "help":
    print_help()
    sys.exit(0)
elif action == "version":
    print programName + " " + version
    print "Copyright (C) 2008 Canonical Ltd."
    sys.exit(0)

try:
    ufw = UFWFrontend(UFWBackendIptables(dryrun))
except UFWError, e:
    error(e.value)
except Exception:
    raise

if action == "logging-on":
    ufw.set_loglevel("on")
elif action == "logging-off":
    ufw.set_loglevel("off")
elif action == "default-allow":
    ufw.set_default_policy("allow")
elif action == "default-deny":
    ufw.set_default_policy("deny")
elif action == "status":
    ufw.get_status()
elif action == "enable":
    ufw.set_enabled(True)
elif action == "disable":
    ufw.set_enabled(False)
elif action == "allow" or action == "deny":
    ufw.set_rule(rule)

sys.exit(0)

